<pre class='metadata'>
Title: Guaranteed copy elision for named return objects
Shortname: D2025
Revision: 1
Audience: EWGI, EWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Anton3/cpp-proposals/blob/master/draft/d2025r1.bs">https://github.com/Anton3/cpp-proposals/blob/master/draft/d2025r1.bs</a>
!Current: <a href="https://github.com/Anton3/cpp-proposals/blob/master/draft/d2025r1.html">https://github.com/Anton3/cpp-proposals/blob/master/draft/d2025r1.html</a>
Editor: Anton Zhilin, antonyzhilin@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes, dfn yes
Default Highlight: c++
Abstract:
  This proposal aims to provide guaranteed copy elision for common cases of local variables being returned from a function.
Date: 2020-05-06
</pre>

<style>
ins {
  background-color: #CCFFCC;
  text-decoration: none;
}
del {
  background-color: #FFCACA;
  text-decoration: none;
}
.warning-note {
  background-color: #FCFAEE;
  border-color: #E0CB52;
  overflow-x: auto;
  overflow-y: auto;
  clear: both;
}
</style>

# Revision history # {#revision}

R1 (post-Prague):

- Renamed "named return object" to "return variable"
- Rewrote [[#wording]] completely
- Fixed an issue where `return` statements in nested lambdas affected copy elision
- Fixed an issue where the function return object was seemingly constructed and destroyed multiple times
- Fixed the invalidation of optimizations: [[#invalidation]]
- Applied several fixes to copy elision requirements: [[#req-change]]
- Moved the wording for guaranteed copy elision to <a href="http://eel.is/c++draft/class.copy.elision">[class.copy.elision]</a>
- Used the same terms for copy elision and guaranteed copy elision
- Added some wording for trivially-copyable types and expanded [[#trivial-temporaries]] section
- Clarified the intent of allowing non-copyable, non-movable types: [[#proposal]]
- Expanded the [[#motivation]] section
- Added more [[#examples]]
- Added [[#pin]] subsection
- Added [[#more-temporaries]] subsection

# Motivation # {#motivation}

<dfn dfn-type="abstract-op" lt="guaranteed copy elision">Guaranteed copy elision</dfn> means that in some scenarios that were (perhaps, potentially or previously) covered by <a href="http://eel.is/c++draft/class.copy.elision#3">copy elision</a>, copy-initialisation is now guaranteed not to happen, and the type that was previously potentially copied can now be non-copyable, non-movable. With the accepted [[P0135R0]] proposal, C++17 provides guaranteed copy elision for when a prvalue is returned from a function — this flavor of copy elision is known as Return Value Optimization (RVO). (The absence of copies flows naturally from the updated value categories, so it is no longer copy elision or an optimization.)

```cpp
widget setup_widget(int x) {
  return widget(x);  // guaranteed "RVO"
}
```

Meanwhile, the other cases of copy elision are still optional. The flavor of copy elision that is allowed when a local variable is [$to return a variable|returned$] is known as Named Return Value Optimization (NRVO). As of C++20, NRVO is not guaranteed, which sometimes enforces rewriting the code in a way that is less readable or efficient.

## Construct-cook-return ## {#construct-cook-return}

Sometimes we want to create an object, set it up and return it.

```cpp
widget setup_widget(int x) {
  widget w;
  w.set_x(x);
  return w;  // non-guaranteed NRVO
}
```

Implementations usually perform NRVO in such simple cases, but `widget` must be at least movable. This situation is unacceptable in these cases, among others:

- If the setup process includes taking a pointer to `w` and storing it elsewhere
- If `widget` is non-copyable non-movable, because its memory location is critically important to its functionality, e.g. `std::mutex`
- If `widget` is non-copyable, because it manages resources that are not easy to copy, and non-movable, because it does not have an empty state, e.g. `open_file` and `not_null_ptr<T>`

On practice, the workaround can be either:

- Two-stage initialization, where a local variable is constructed in its destination (e.g. using the default constructor) and is then immediately passed to function(s) by reference in order to complete the setup of the object
- Always storing the object on heap, e.g. by returning `std::unique_ptr<widget>` instead of `widget` from factory functions

Both "solutions" are often viewed as anti-patterns. A proper solution should allow for the construct-cook-return pattern, even if a copy or move is not affordable.

## Construct-cleanup-return ## {#construct-cleanup-return}

With [[P1144R5]], we may be able to relocate elements out of containers, which should be more efficient:

```cpp
widget widget_owner::pilfer() {
  widget w = this->relocate_internal();
  this->cleanup_storage();
  return w;  // non-guaranteed NRVO
}
```

Unfortunately, such a clean-up work leads to the abscence of guaranteed copy elision. It can, however, be worked around using a facility like `scope_success` from [[P0052R9]]:

```cpp
widget widget_owner::pilfer() {
  auto s = scope_success([&]{ this->cleanup_storage(); });
  return this->relocate_internal();  // guaranteed "RVO"
}
```

The code rewritten in such a way is less straightforward and contains the potential overhead of `scope_success`.

## Operator rewrites ## {#operator-rewrites}

[[P1046R2]] proposes automatically generating `operator++(int)` for a type that implements `operator+=`. Its definition would look approximately as follows:

```cpp
T T::operator++(int) {
  T result = *this;  // intended copy
  *this += 1;
  return result;  // guaranteed NRVO
}
```

In order to deliver on the promise of guaranteed NRVO there, we would have to use the `scope_success` trick described above.

# Proposed solution # {#proposal}

If copy elision for a returned variable is allowed, and all <a href="http://eel.is/c++draft/stmt.if#def:discarded_statement">non-discarded</a> `return` statements in its <a href="http://eel.is/c++draft/basic.scope#def:potential_scope">potential scope</a> [$to return a variable|return$] the variable, then [$guaranteed copy elision|copy elision is guaranteed$]. The type of the variable is allowed to be non-copyable, non-movable.

(For the purposes of brevity, the explanation above is not rigorous; see [[#wording]] for a rigorous explanation.)

## Examples ## {#examples}

Constructing and returning a `widget`, guaranteed copy elision applies (since C++17):

```cpp
widget setup_widget(int x) {
  return widget(x);
}
```

Constructing, "cooking" and returning a `widget`, guaranteed copy elision applies:

```cpp
widget setup_widget(int x) {
  auto w = widget(x);
  int y = process(x);
  w.set_y(y);
  return w;
}
```

A more contrived example where guaranteed copy elision applies:

```cpp
widget setup_widget() {
  while (…) {
    auto w = widget(1);
    if (…) return w;
    if (…) break;
    if (…) throw …;
    if (…) return w;
  }
  return widget(2);
}
```

An example where guaranteed copy elision does not apply:

<xmp>
widget setup_widget() {
  auto w = widget(1);
  if (…) {
    return w;  //!
  } else {
    return widget(2);
  }
}
</xmp>

The example above can be "fixed" so that guaranteed copy elision does apply:

```cpp
widget setup_widget() {
  if (…) {
    auto w = widget(1);
    return w;
  } else {
    return widget(2);
  }
}
```

In the following example, `return two;` lies in the potential scope of `one`, so guaranteed copy elision does not apply to `one`:

<xmp>
widget test() {
  widget one;
  return one;  //!
  widget two;
  return two;
}
</xmp>

Constructing, setting up and passing an object as a parameter using an immediately invoked lambda expression (`consume_widget`'s parameter is directly initialized with `x`):

```cpp
void consume_widget(widget);

void test(int x) {
  int y = process(x);
  consume_widget([&] {
    auto w = widget(x);
    w.set_y(y);
    return w;
  }());
}
```

Guaranteed copy elision is unaffected by a nested class, a lambda capture and a discarded `return` statement:

```cpp
widget test() {
  widget w;
  struct s { widget f() { return widget(); } };
  auto l = [&w]() { return widget(); }();
  if constexpr (false) { return widget(); }
  return w;
}
```

Guaranteed copy elision applies in constant evaluation context:

```cpp
constexpr std::mutex test() {
  std::mutex m;
  return m;
}
constinit std::mutex m = test();
```

Guaranteed copy elision applies to all the 3 return statements. `w1`, `w2` and `w3` will occupy the return slot at different times:

```cpp
widget test() {
  {
    {
      widget w1;
      if (toss_a_coin()) return w1;
    }
    widget w2;
    if (toss_a_coin()) return w2;
  }
  widget w3;
  return w3;
}
```

With proposed wording, copy elision applies for exceptions caught by value, and is guaranteed in this case:

```cpp
widget test() {
  try {
    throw widget();
  } catch (widget w) {
    return w;
  }
}
```

With proposed wording, copy elision applies for parenthesized names, and will be guaranteed in this case:

```cpp
widget test() {
  auto w = widget();
  return ((w));
}
```

## Proposed wording ## {#wording}

The wording in this section is relative to WG21 draft [[!N4842]].

Add a new section in <a href="http://eel.is/c++draft/class.copy.elision">[class.copy.elision]</a>:

<blockquote>
It is said that a `return` statement <dfn dfn-type="abstract-op" lt="to return a variable">returns</dfn> a variable when its operand is a (possibly parenthesized) *id-expression*, for which the name lookup (<a href="http://eel.is/c++draft/basic.lookup">[basic.lookup]</a>) finds the variable, unless the variable is captured by a *lambda-expression* enclosing the `return` statement.

A variable with automatic storage duration is called a <dfn dfn-type="abstract-op">potential return variable</dfn> when all of the following conditions are satisfied:

- the variable is not a function parameter,

- the type of the variable is a class type, is not `volatile`-qualified, and is the same (ignoring cv-qualification) as the return type of the immediately enclosing function or *lambda-expression*, and

- at least one non-discarded (<a href="http://eel.is/c++draft/stmt.if">[stmt.if]</a>) `return` statement in its potential scope (<a href="http://eel.is/c++draft/basic.scope">[basic.scope]</a>) and in the same immediately enclosing function or *lambda-expression* as the variable declaration [$to return a variable|returns$] the variable. [ *Note:* The enclosing function cannot be a coroutine. — *end note* ]

If additionally, all of the mentioned `return` statements [$to return a variable|return$] the variable, then the variable is called a <dfn dfn-type="abstract-op">return variable</dfn>.

If the potential scope of a [$return variable$] is exited in a way other than by executing a statement that [$to return a variable|returns$] it (or destruction of a local variable is terminated by an exception), the return variable is considered a normal local variable that denotes an object of automatic storage duration. [ *Note:* In particular, on exit from the scope, the object is destroyed, among other objects of automatic storage duration, in the reverse order of construction (<a href="http://eel.is/c++draft/stmt.jump">[stmt.jump]</a>). If destruction of a local variable is terminated by an exception, the return variable may be destroyed out of normal order, as per <a href="http://eel.is/c++draft/except.ctor">[except.ctor]</a>. — *end note* ]

If the potential scope of a [$return variable$] is exited by executing a statement that [$to return a variable|returns$] it (and destruction of local variables is not terminated by an exception), then the variable denotes the result object of the function call expression. The statement that returns the variable performs no copy-initialization (<a href="http://eel.is/c++draft/stmt.return">[stmt.return]</a>) and does not cause the destruction of the object (<a href="http://eel.is/c++draft/stmt.jump">[stmt.jump]</a>). Except for that, until the control is transferred out of the function, the variable shall be treated as a local variable with automatic storage duration, and `const` and `volatile` semantics (<a href="http://eel.is/c++draft/dcl.type.cv">[dcl.type.cv]</a>) applied to the object correspond to the type of the return variable.

[ *Note:* If the [$return variable$] is of a trivially-relocatable type, then a temporary object may be introduced, with a subsequent copy or move (<a href="http://eel.is/c++draft/class.temporary">[class.temporary]</a>). In this case the variable may denote the temporary. — *end note* ]

Until the control is transferred out of the function, if the value of the object of the [$return variable$] or any of its subobjects is accessed through a glvalue that is not obtained, directly or indirectly, from the variable, the value of the object or subobject thus obtained is unspecified.
</blockquote>

<blockquote class="note warning-note">
Note:
The definition avoids mentioning the object a [$return variable$] names before stating that it may name the result object of the function call expression.
</blockquote>

<blockquote class="note warning-note">
Note:
The object of a [$return variable$] is analogous to an object under construction. Some wording was borrowed from <a href="http://eel.is/c++draft/class.ctor#5">[class.ctor]</a> and <a href="http://eel.is/c++draft/class.cdtor#2">[class.cdtor]/2</a>.
</blockquote>

<blockquote class="issue">
Too many new terms might have been introduced: [$to return a variable$], [$potential return variable$], [$return variable$].
</blockquote>

<blockquote class="issue">
Should we say "function or *lambda-expression*", or is it enough to say "function"?
</blockquote>

Modify <a href="http://eel.is/c++draft/class.copy.elision#1">[class.copy.elision]/1</a>:

<blockquote>
<del>in a `return` statement in a function with a class return type, when the *expression* is the name of a non-volatile object with automatic storage duration (other than a function parameter or a variable introduced by the *exception-declaration* of a *handler* (<a href="http://eel.is/c++draft/except.handle">[except.handle]</a>)) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the object directly into the function call's return object</del> <ins>the implementation may treat a [$potential return variable$] as a [$return variable$]</ins>
</blockquote>

Modify <a href="http://eel.is/c++draft/stmt.jump#2">[stmt.jump]/2</a>:

<blockquote>
On exit from a scope (however accomplished), objects with automatic storage duration that have been constructed in that scope are destroyed in the reverse order of their construction. [ *Note:* For temporaries, see <a href="http://eel.is/c++draft/class.temporary">[class.temporary]</a>. <ins>For objects participating in copy elision, see <a href="http://eel.is/c++draft/class.copy.elision">[class.copy.elision]</a>.</ins> — *end note* ] Transfer out of a loop, out of a block, or back past an initialized variable with automatic storage duration involves the destruction of objects with automatic storage duration that are in scope at the point transferred from but not at the point transferred to. (See <a href="http://eel.is/c++draft/stmt.dcl">[stmt.dcl]</a> for transfers into blocks). […]
</blockquote>

Modify <a href="http://eel.is/c++draft/stmt.return#2">[stmt.return]/2</a>:

<blockquote>
[…] A `return` statement with any other operand shall be used only in a function whose return type is not cv `void`; the `return` statement initializes the glvalue result or prvalue result object of the (explicit or implicit) function call by copy-initialization from the operand <ins>(except when copy elision applies (<a href="http://eel.is/c++draft/class.copy.elision">[class.copy.elision]</a>))</ins>. […]
</blockquote>

Modify <a href="http://eel.is/c++draft/stmt.dcl#2">[stmt.dcl]/2</a>:

<blockquote>
Variables with automatic storage duration are initialized each time their *declaration-statement* is executed. <ins>[ *Note:*</ins> Variables with automatic storage duration declared in the block are destroyed on exit from the block <ins>as described in</ins> <del>(</del> <a href="http://eel.is/c++draft/stmt.jump">[stmt.jump]</a> <del>)</del>. <ins>— *end note* ]</ins>
</blockquote>

<blockquote class="note warning-note">
Note:
The modified sentence currently duplicates the specification in <a href="http://eel.is/c++draft/stmt.jump#2">[stmt.jump]/2</a>. If the sentence is turned into a reference, it will not have to duplicate the exception for return variables.
</blockquote>

# Frequently Asked Questions # {#faq}

## Is "return variable" a good term choice? ## {#term}

<blockquote class="issue">
"[$return variable|Return variable$]" might not be the best term for our purposes.
</blockquote>

A previous revision of this proposal (R0) used the term "named return object". That term choice was unfortunate, because it refers to a variable, not to an object. And a variable cannot be "unnamed", so that was excessive.

Some alternative choices:

- result variable
- return object name
- result object name
- transparently returned variable

## Have requirements for copy elision changed? ## {#req-change}

There are multiple issues with current wording for copy elision. While <a href="http://eel.is/c++draft/class.copy.elision#3">[class.copy.elision]/3</a> has recently been updated ([[CWG1579]]), <a href="http://eel.is/c++draft/class.copy.elision#1">[class.copy.elision]/1</a> has not. Proposed wording cleans up those issues.

### Parentheses are now allowed around the variable name ### {#req-parentheses}

<blockquote>
<del>[…] the *expression* is the name of […]</del>
<ins>[…] a (possibly parenthesized) *id-expression* […]</ins>
</blockquote>

In the following example, both `x` and `y` are considered [$return variable|return variables$]:

```cpp
widget foo() {
  widget x;
  return (x);
}

widget bar() {
  widget y;
  return (((y)));
}
```

Implementation divergence has been discovered. Clang and MSVC do perform copy elision there, but GCC does not. Consequently, this change may be delivered by a Defect Report.

### Copy elision no longer applies to lambda captures ### {#req-lambda}

<blockquote>
<ins>[…] unless the variable is captured by a *lambda-expression* enclosing the `return` statement […]</ins>
</blockquote>

In the following case, name lookup for `w` in the inner `return` statement finds exactly the outer `w` variable. The `w` expression does satisfy the "name of a non-volatile object with automatic storage duration" condition. Therefore, copy elision can currently apply to the inner return statement. This seems unintentional; none of the major compilers apply copy elision in this case.

```cpp
widget foo() {
  widget w;
  return [&w] {
    return w;
  }();
}
```

This case will no longer be eligible for copy elision under the proposed wording. This change may be delivered by a Defect Report as well.

### Copy elision now applies to exceptions caught by value ### {#req-value-exeptions}

<blockquote class="issue">
The previous restriction in this case looks like not-a-defect. Should this change belong to a separate proposal?
</blockquote>

<blockquote>
<del>other than […] or a variable introduced by the *exception-declaration* of a *handler* (<a href="http://eel.is/c++draft/except.handle">[except.handle]</a>
</blockquote>

This edge case will be removed, following the proposed wording. Observe the following example:

```cpp
struct widget {
  widget();
  widget(const widget&);
  widget(widget&&);
};

void bar() noexcept(false);
bool toss_a_coin();

widget foo() {
  try {
    bar();
    return widget();
  } catch (widget w) {
    if (toss_a_coin()) {
      return w;
    }
    return widget();
  }
}
```

Without the proposed wording applied, the exception object will be copied to `w`, then it will be moved out in `return w;` (it satisfies the *implicitly movable entity* conditions, see <a href="http://eel.is/c++draft/class.copy.elision#3.1">[class.copy.elision]/(3.1)</a>). Unless the compiler can prove that the `toss_a_coin()` call never returns `true`, in which case <a href="http://eel.is/c++draft/class.copy.elision#1.4">[class.copy.elision]/(1.4)</a> can apply, in which case `w` can be turned into an lvalue reference.

If we remove the move-constructor from `widget` (but leave the copy-constsuctor; most standard exception types are defined as that), then <a href="http://eel.is/c++draft/class.copy.elision#1.4">[class.copy.elision]/(1.4)</a> can apply regardless of `toss_a_coin`. In case it is applied, `w` is treated as an lvalue reference, implicit movability of `w` does not matter, and `return w;` performs a copy, which cannot be elided. A sufficiently smart compiler can avoid all copies and moves on the path where `toss_a_coin()` returns `false`.

With the proposed wording applied, the exception object will be copied to `w`, and copy elision is guaranteed for `return w;`. <a href="http://eel.is/c++draft/class.copy.elision#1.4">[class.copy.elision]/(1.4)</a>, if applied,
prevents guaranteed copy elision, requiring the compiler to prove that this does not change the meaning of the program. From the optimization point-of-view, almost nothing changes, but it is guaranteed that no more than 1 copy is made.

Overall, it seems that this is an edge case that can be removed painlessly. To guarantee the abscence of copies for the exception object, one should catch the exception by reference, instead of catching by copy and complaining about the copy. On the other hand, when a copy is intended, this proposal ensures that the caught exception is treated as well as any other variable.

## Are the proposed changes source or ABI breaking? ## {#abi}

Propored changes *can break* constant expressions that rely on effects of the copy-initialization and destruction that are proposed to be elided. The defect report [[CWG2278]], requiring that copy elision is not performed in constant expressions, has been presented in March, 2018.

However, relying on the effects of copy-initialization and destruction in constant expressions is considered exotic, and real-world code breakage is deemed to be minimal.

The proposal prohibits some corner-case copy elision ([[#req-lambda]]), which was most probably a defect. Note that previously, copy elision could not be relied upon by portable programs.

The proposal allows or guarantees some new cases of copy elision ([[#req-parentheses]]), not providing them was arguably a defect. Some additional edge-case copy elision ([[#req-value-exeptions]]) is now allowed or guaranteed; programs that relied on copy elision not applying there (non-portable or corner-care scenarios) will no longer be valid.

The proposal is *not* ABI-breaking, because, in all known implementations, whether NRVO is applied for a function does not impact its calling convention.

## What are the costs associated with the proposed changes? ## {#costs}

There is no runtime cost associated with the proposed copy elision, because storage for the return object is allocated on stack before the function body starts executing, in all known implementations.

The proposal will make declarations of local variables with automatic storage duration context-dependent: storage of a variable will depend on `return` statements in its potential scope. However, this analysis is local and purely syntactic. The impact on compilation times is thus deemed to be minimal.

Compilers that already do NRVO will enable it (or at least the required part of it) in all compilation modes. The proposal might even have a positive impact on compilation time, because such implementations will not have to check whether copy-initialization on the return type can be performed.

## What about trivially-copyable temporaries? ## {#trivial-temporaries}

According to <a href="http://eel.is/c++draft/class.temporary">[class.temporary]</a>, the implementation is allowed to create a copy when the object of a trivially-copyable type is returned. That is also the case when the copied object participates in "guaranteed RVO" (C++17) or "guaranteed NRVO" (proposed). If the address of such an object is saved to a pointer variable, the pointer will become dangling on return from the function:

```cpp
class A {
public:
  A* p;
  A() : p(this) {}
}

A rvo() {
  return A();
}
A x = rvo();   // x.p may be dangling

A* q{};
A nrvo() {
  A y = A();
  q = &y;
  return y;
}
A z = nrvo();  // z.p may be dangling
               // q may be dangling
```

Changing <a href="http://eel.is/c++draft/class.temporary">[class.temporary]</a> and prohibiting such temporaries would cause ABI breakage, and is infeasible. ABI issues aside, it is not desirable to prohibit optimizations related to liberal treatment of trivially-copyable types.

The amount of copying will still be reduced even for those cases. Currently it is implementation-defined whether a copy is elided (<a href="http://eel.is/c++draft/class.copy.elision#1">[class.copy.elision]/1</a>) and whether a temporary is created (<a href="http://eel.is/c++draft/class.temporary#3">[class.temporary]/3</a>). Depending on that, either 0, 1 or 2 copies may be performed (counting moves as copies). For example:

```cpp
std::pair<int, int> foo() {
  auto a = std::pair(1, 2);
  return a;
}

auto b = foo();
```

Currently, 4 scenarios are possible:

1. Copy elided, no temporary. `a` and `b` denote the same object. 0 copies
2. Copy elided, temporary. `a` denotes the temporary, trivially copied or moved into `b`. 1 copy or move
3. Copy not elided, no temporary. `a` is a normal local variable, implicitly moved into `b`. 1 move
4. Copy not elided, temporary. `a` is implicitly moved into the temporary, which is then trivially copied or moved into `b`. 1 copy, 1 move or 2 moves

With this proposal accepted, only scenarios 1 and 2 are possible.

Regardless of trivially-copyable types, it is difficult to talk about copy elision for non-class types, because a function call with result of a non-class type might not have a result object (see <a href="http://eel.is/c++draft/expr.prop#basic.lval-5">[expr.prop]/5</a>).

## What about the invalidation of optimizations? ## {#invalidation}

Observe an example:

```
struct A {
  int x;
  A(int x) : x(x) {}
  A(const A& o) : x(o.x) {}
};
extern A global;

A foo() {
  A local(2);
  local.x += global.x;
  return local;
}
```

Currently, copy elision is not guaranteed, it cannot make invalid code valid. `global` in `global.x` can be assumed to have nothing common with local, e.g. `global` cannot be defined as `A global = foo();`. Compilers use this knowledge to optimize `foo` to the equivalent of:

```
A foo() {
  return A(2 + global.x);
}
```

Under this proposal, `local` and `global` can be assumed to be distinct too, for a different reason. Inside `A global = foo();`, `global` and `local` are guaranteed to denote the same object. `local` is a [$return variable$]. Before `foo` returns, the value of `local.x` is accessed through glvalue `global.x` that is not obtained from `local`, thus the value of `global.x` is unspecified.

In summary, no optimizations will be invalidated. Code which would require invalidation of optimizations for correctness is kept incorrect in a way that does not cause source or ABI breakage.

# Alternative solutions # {#alternatives}

## Implement similar functionality using existing features ## {#existing-features}

We can implement similar functionality, with cooperation from the returned object type, in some cases.

Suppose the `widget` class defines the following constructor, among others:

```cpp
template <typename... Args, std::invocable<widget&> Func>
widget(Args&&... args, Func&& func)
  : widget(std::forward<Args>(args)...)
  { std::invoke(std::forward<Func>(func)), *this); }
```

We can then use it to observe the result object of a prvalue through a reference before returning it:

```cpp
widget setup_widget(int x) {
  int y = process(x);

  return widget(x, [&](widget& w) {
    w.set_y(y);
  });
}
```

However, it requires cooperation from `widget` and breaks when some of its other constructors accept an invocable parameter. We cannot implement this functionality in general.

## Guarantee NRVO in more cases ## {#more-nrvo}

```cpp
class builder {
public:
  builder();
  widget build();
  widget rebuild();
  …
};

widget foo() {
  builder b;
  widget w = b.build();
  if (…) return b.rebuild();
  return w;
}
```

NRVO will **not** be guaranteed for `w`, according to this proposal. Meanwhile, one could say that it could be guaranteed: if the condition is true, then we could arrange it so that `w` (which is stored as the return object) is destroyed before `b.rebuild()` is called.

However, what if `build` saves a pointer to the returned object, which is then used in `rebuild`? Then the `b.rebuild()` call will try to reach for `w`, which will lead to undefined behavior.

While the compiler can in some cases analyze the control flow and usage patterns (usually after inlining is performed), this is impossible in general. (This is why a previous attempt at guaranteeing NRVO was shut down, see [[CWG2278]].) The limitations of the proposed solution describe the cases where correctness can always be guaranteed without overhead and non-local reasoning.

## Require an explicit mark for return variables ## {#explicit-mark}

As an alternative, [$return variable|return variables$] could require a specific attribute or a mark of some sort in order to be eligible for guaranteed copy elision:

```cpp
widget setup_widget(int x) {
  auto w = widget(x) [[nrvo]];
  w.set_x(x);
  return w;
}
```

The benefit of requiring the mark is that the compiler would not have to determine for each local variable whether it could be a return variable. However, the cost of the compile-time checks is deemed to be low, while there would be some language complexity cost associated with the mark.

## Alias expressions ## {#alias-expressions}

Alias expressions would be a new type of expression. An <dfn dfn-type="abstract-op">alias expression</dfn> would accept a prvalue, execute a block, providing that block a "magical" reference to the result object of that prvalue, and the alias expression would itself be a prvalue with the original result object:

```cpp
widget setup_widget(int x) {
  return using (w = widget()) {
    w.set_x(x);
  };
}
```

Such a construct would require more wording and special cases on the behavior of the "magical" reference `w` and the underlying object. It would be prohibited to `return` from inside the block of the alias expression. More importantly, alias expressions would introduce the precedent of an expression that contains statements, which has issues with a lot of the standard. And as with [[#explicit-mark|explicit marks]], it introduces more syntax, which the proposed solution avoids.

Alias expressions could also be used to get rid of copies in places other than the return expressions, e.g. when passing a function argument by value:

```cpp
void consume_widget(widget);

void test(int x) {
  consume_widget(using (w = widget()) {
    w.set_x(x);
  });
}
```

The proposed solution can be used with an immediately invoked lambda expression to perform the same task:

```cpp
void consume_widget(widget);

void test(int x) {
  consume_widget([&] {
    widget w;
    w.set_x(x);
    return w;
  }());
}
```

# Future work # {#future-work}

## Guarantee some other types of copy elision ## {#more-elision}

<a href="http://eel.is/c++draft/class.copy.elision#1">[class.copy.elision]/1</a> describes 4 cases where copy elision is allowed. Let us review whether it is feasible to guarantee copy elision in those cases:

- (1.1) is feasible to guarantee with the limitations described in this proposal, because such an "optimization" is always correct, does not introduce overhead and does not require non-local reasoning.

- (1.2) leads to an extra allocation in case the control flow escapes the scope before the throw-expression is executed. It would only be feasible to guarantee when the scope contains no other jump statements, and all the functions called are `noexcept`. Those cases are deemed highly specific, but **can** be tackled in a separate proposal.

- (1.3) requires non-local reasoning and is therefore infeasible to guarantee.

- (1.4) requires non-local reasoning and is therefore infeasible to guarantee.

## Guarantee currently disallowed types of copy elision ## {#disallowed-elision}

Requiring copy elision in more cases than is currently allowed by the standard is a breaking change and is out of scope of this proposal. If another proposal that guarantees copy elision in more cases is accepted, those cases could also be reviewed for feasibility of guaranteed copy elision. This proposal will not be influenced by that future work.

## Reduce the number of moves performed in other cases ## {#other-moves}

This proposal belongs to a group of proposals that aim to reduce the number of moves performed in C++ programs. Within that group, there are two subgroups:

- Some proposals allow to replace moves with operations that are yet cheaper than moves (known as relocation or destructive move): [[N4158]], [[P0023R0]], [[P1144R5]].
- Other proposals aim to remove the need for moving altogether. This proposal, as well as [[P0927R2]], belongs to that group.

The problem solved by the current proposal is orthogonal to the problems dealt with by relocation proposals, as well as to the problem dealt with by P0927R2.

The current proposal combines with [[P0927R2]] nicely. That proposal requires that the lazy parameter is only used once (and forwarded to another lazy parameter or to its final destination), while in some cases it may be desirable to acquire and use it for some time before forwarding. This proposal would allow to achieve it in a clean way, see the immediately invoked lambda expression example.

The changes proposed by this proposal and [[P0927R2]], combined, would allow to implement alias expressions (see the corresponding section) without any extra help from the language:

```cpp
template <typename T, invokable<T&> Func>
T also([] -> T value, Func&& func) {
  T computed = value();
  func(computed);
  return computed;
}

void consume_widget(widget);

void test(int x) {
  consume_widget(also(widget(x), [&](auto& w) {
    w.set_x(x);
  }));
}
```

## Allow temporaries to be created for types other than trivially-copyables ## {#more-temporaries}

Currently, extra copies of the result object are allowed for trivially-copyable types, to allow passing those objects in registers, presumably when it is beneficial for performance. A relocation proposal, such as [[P1144R5]], could allow trivially-relocatable types to be treated the same way. If so, then those types will need to be excluded from guaranteed copy elision.

This important change will be source-breaking and will lead to silent UB and bugs if the relocation proposal (with the exemption for trivially-relocatable types) is accepted in a later C++ version compared to this proposal.

## `std::pin<T>` class ## {#pin}

For trivially copyable types, copy elision will still be non-guaranteed: the compiler may do a trivial copy if it "considers" that this will be beneficial for optimization or for other reasons. Meanwhile, sometimes it is still highly desirable to have this guarantee, e.g. when a pointer to the variable is saved elsewhere. To help in this situation, we may want a non-movable wrapper:

```
template <typename T>
struct pin {
  T value;

  pin& operator=(pin&& other) = delete;
};

pin<int> test() {
  pin<int> result(42);
  watch(&result);
  return result;
}
```

For `pin` to be an aggregate, <a href="http://eel.is/c++draft/dcl.init.aggr">[dcl.init.aggr]</a> needs to be relaxed to allow user-declared copy and move constructors.

# Acknowledgements # {#acknowledgements}

Thanks to Agustín Bergé, Arthur O'Dwyer, Krystian Stasiowski and everyone else who provided feedback on a draft of this proposal.

Special thanks to Antony Polukhin for championing the paper.
